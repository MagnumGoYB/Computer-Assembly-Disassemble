<!DOCTYPE html>
<html lang="en">

<head>
    <title></title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans+SC:100,300,400,500,700&amp;subset=chinese-simplified">
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:900' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Playfair+Display:400italic' rel='stylesheet' type='text/css'>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel='stylesheet' type='text/css'>
</head>

<body>
    <div id="loading">
        <h1 class="ml13">Loading</h1>
    </div>
    <div id="full-screen">
        <canvas id="canvas"></canvas>
    </div>
    <div id="feedback"></div>
    <div id="reset">
        <div class="reset-box">
            <button type="button" id="reset-btn" class="reset-btn"><i class="fa fa-rotate-left"></i></button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/2.0.2/anime.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="js/loading.js"></script>

    <script src="js/three.min.js"></script>
    <script src="js/TrackballControls.js"></script>
    <script src="js/DragControls.js"></script>
    <script src="js/LoaderSupport.js"></script>
    <script src="js/OBJLoader2.js"></script>
    <script src="js/MTLLoader.js"></script>
    <script src="js/stats.min.js"></script>

    <script src="js/tween.js"></script>
    <script src="js/animation.js"></script>

    <script>
        var Boot = function (elementToBindTo) {
            this.raycaster = null;
            this.renderer = null;
            this.canvas = elementToBindTo;
            this.aspectRatio = 1;
            this.recalcAspectRatio();
            this.scene = null;
            this.cameraDefaults = {
                posCamera: new THREE.Vector3(150, 120, 200),
                posCameraTarget: new THREE.Vector3(0, 0, 0),
                near: 0.1,
                far: 10000,
                fov: 45
            };
            this.camera = null;
            this.cameraTarget = this.cameraDefaults.posCameraTarget;
            this.controls = null;

            this.workerDirector = new THREE.LoaderSupport.WorkerDirector(THREE.OBJLoader2);
            this.logging = {
                enabled: false,
                debug: false
            };
            this.workerDirector.setLogging(this.logging.enabled, this.logging.debug);
            this.workerDirector.setCrossOrigin('anonymous');
            this.workerDirector.setForceWorkerDataCopy(true);

            this.allAssets = [];
            this.feedbackArray = null;
            this.running = false;

            this.mouse = new THREE.Vector2();
            this.INTERSECTED = null;

            this.queueItems = [{
                    name: 'Motherboard',
                    visible: true,
                    path: 'models/obj/Motherboard/',
                    position: [0, 4, 0],
                    rotation: [0, 0, -1.57]
                }, {
                    name: 'CPU',
                    path: 'models/obj/CPU/',
                    scale: 1.7,
                    position: [12.4, 1, -6],
                    rotation: [0, 0, -1.57]
                }, {
                    name: 'CPU-Cooler',
                    path: 'models/obj/CPU-Cooler/',
                    position: [12.4, 8.5, -5],
                    rotation: [0, 0, -1.57]
                }, {
                    name: 'RAM',
                    path: 'models/obj/RAM/',
                    scale: 1.88,
                    position: [9.6, 4.5, 21],
                    rotation: [0, 0, -1.57]
                }, {
                    name: 'Chassis',
                    path: 'models/obj/Chassis/',
                    position: [16, 74.5, 43.5],
                    rotation: [0, 0, -1.57]
                }, {
                    name: 'GPU',
                    path: 'models/obj/GPU/',
                    scale: 1.88,
                    position: [-18, 15, -20],
                    rotation: [0, 0, -1.57]
                }, {
                    name: 'Disk',
                    path: 'models/obj/Disk/',
                    scale: 1.88,
                    position: [-27.3, 15, 32.5],
                    rotation: [0, 0, -1.57]
                }, {
                    name: 'CD-ROM',
                    path: 'models/obj/CD-ROM/',
                    scale: 1.81,
                    position: [30.3, 17, 27.7],
                    rotation: [0, 0.01, -1.57]
                }, {
                    name: 'Power',
                    path: 'models/obj/Power/',
                    scale: 1.8,
                    position: [23.5, 227, 14],
                    rotation: [0, 0, -1.57]
                }, {
                    name: 'Board',
                    path: 'models/obj/Board/',
                    scale: 1.805,
                    position: [16.2, -125, 44],
                    rotation: [0, 0, -1.57]
                }, {
                    name: 'Monitor',
                    path: 'models/obj/Monitor/',
                    scale: 1.6,
                    position: [12.5, -161, 33],
                    rotation: [0, 0, -1.57]
                }, {
                    name: 'Mouse',
                    path: 'models/obj/Mouse/',
                    scale: 1.6,
                    position: [14.5, -162.2, 45],
                    rotation: [0, 0, -1.57]
                }
            ];
            this.workerCount = 4;
            this.streamMeshes = true;
            
            this.chassisItems = [];
            this.mul = 2;
            this.currentStep = 1;
            this.steps = ['', 'CPU', 'CPU-Cooler', 'RAM', 'Chassis', 'GPU', 'Disk', 'Power', 'CD-ROM', 'Board', 'Monitor', 'Mouse'];
            this.stepsOptions = [null, {
                position: {
                    y: 30
                },
                cameraPosition: {
                    x: 80,
                    y: 100,
                    z: 10
                }
            }, {
                position: {
                    y: 40
                }
            }, {
                position: {
                    y: 15
                },
                cameraPosition: {
                    x: 0,
                    y: 80,
                    z: 150
                }
            }, {
                position: {
                    y: 30
                },
                cameraPosition: {
                    x: 110,
                    y: 130,
                    z: 80
                }
            }, {
                position: {
                    y: 50
                },
                cameraPosition: {
                    x: -120,
                    y: 150,
                    z: 40
                }
            }, {
                position: {
                    y: 60,
                    x: -20,
                    z: 20
                },
                sceneRotation: {
                    z: Math.PI / 2
                },
                cameraPosition: {
                    x: -150,
                    y: 30,
                    z: -100
                }
            }, {
                position: {
                    y: 280,
                    z: 80
                },
                cameraPosition: {
                    x: -200,
                    y: 100,
                    z: 90
                }
            }, {
                position: {
                    y: 70,
                    x: 10,
                    z: 10
                }
            }, {
                position: {
                    z: -40
                }
            }, {
                position: {
                    y: -90
                }, 
                cameraPosition: {
                    x: 0,
                    y: 150,
                    z: -280
                }
            }, {
                position: {
                    y: -90
                }
            }];
        };
        Boot.prototype = {
            constructor: Boot,
            initGL: function () {
                this.raycaster = new THREE.Raycaster();
                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.canvas,
                    antialias: true,
                    autoClear: true
                });
                this.renderer.setClearColor(0xFFFFFF);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xD6D9DC);

                this.camera = new THREE.PerspectiveCamera(this.cameraDefaults.fov, this.aspectRatio, this.cameraDefaults
                    .near, this.cameraDefaults.far);
                this.resetCamera();
                this.controls = new THREE.TrackballControls(this.camera, this.renderer.domElement);
                this.controls.rotateSpeed = 2.5;
                this.controls.zoomSpeed = 1.2;
                this.controls.panSpeed = 0.8;

                var ambientLight = new THREE.AmbientLight(0xFFFFFF, 1);
                var directionalLight = new THREE.DirectionalLight(0xFFFFFF, 0.3);
                directionalLight.position.set(-300, 300, -300);
                directionalLight.castShadow = true;
                var directional2Light = new THREE.DirectionalLight(0xFFFFFF, 0.3);
                directional2Light.position.set(-300, 0, 300);
                directional2Light.castShadow = true;
                var directional3Light = new THREE.DirectionalLight(0xFFFFFF, 0.3);
                directional3Light.position.set(300, -300, 0);
                directional3Light.castShadow = true;

                this.scene.add(ambientLight);
                this.scene.add(directionalLight);
                this.scene.add(directional2Light);
                this.scene.add(directional3Light);

                var grid = new THREE.GridHelper(1000, 100, 0x404040, 0x404040);
                grid.material.opacity = 0.05;
                grid.material.transparent = true;
                // this.scene.add(grid);

                var axes = new THREE.AxisHelper(1000);
                // this.scene.add(axes);

                this.chassisGroup = new THREE.Group();
                this.chassisGroup.name = 'ChassisGroup';
                this.scene.add(this.chassisGroup);

                this.enqueueAllAssests(this.queueItems, this.workerCount, this.streamMeshes);
            },
            onMouseDown: function (e) {
                e.preventDefault();
                this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);
                var scensObjs = [];
                this.scene.children.forEach(child => {
                    for (var i = 0; i < child.children.length; i++) {
                        var obj = child.children[i];
                        scensObjs.push(obj);
                    }
                });
                var intersects = this.raycaster.intersectObjects(scensObjs);

                var objs = [];
                for (var i = 0; i < intersects.length; i++) {
                    var intersect = intersects[i];
                    if (intersect.object instanceof THREE.Mesh) {
                        var obj = intersect.object.parent;
                        obj.userData.distance = intersect.distance;
                        objs.push(obj);
                    }
                }
                objs = objs.sort(function (a, b) {
                    return a.userData.distance - b.userData.distance;
                });
                console.log(objs)
                if (objs[0]) {
                    if (objs[0].name == this.steps[this.currentStep]) {
                        this.trigger(objs[0]);
                    }
                }
            },
            onMouseMove: function(e) {},
            enqueueAllAssests: function (items, maxWebWorkers, streamMeshes) {
                if (this.running) {
                    return;
                } else {
                    this.running = true;
                }
                var scope = this;
                scope.workerDirector.objectsCompleted = 0;
                scope.feedbackArray = [];
                scope.reportDonwload = [];
                var i;
                var maxQueueSize = items.length;
                for (i = 0; i < maxWebWorkers; i++) {
                    scope.feedbackArray[i] = '加载程序 #' + i + ': 等待反馈...';
                    scope.reportDonwload[i] = true;
                }
                scope._reportProgress(scope.feedbackArray.join('\<br\>'));

                var callbackOnLoad = function (event) {
                    var instanceNo = event.detail.instanceNo;
                    scope.reportDonwload[instanceNo] = false;
                    scope.allAssets.push(event.detail.loaderRootNode);

                    var msg = '加载程序 #' + instanceNo + ': 已完成加载: ' + event.detail.modelName +
                        ' (#' + scope.workerDirector.objectsCompleted + ')';
                    if (scope.logging.enabled) console.info(msg);
                    scope.feedbackArray[instanceNo] = msg;
                    scope._reportProgress(scope.feedbackArray.join('\<br\>'));

                    if (scope.workerDirector.objectsCompleted + 1 === maxQueueSize) {
                        scope.running = false;
                        console.log('所有对象加载完成！');
                        scope.initialize();
                    }
                };

                var callbackReportProgress = function (event) {
                    var instanceNo = event.detail.instanceNo;
                    var text = event.detail.text;

                    if (scope.reportDonwload[instanceNo]) {
                        var msg = '加载程序 #' + instanceNo + ': ' + text;
                        if (scope.logging.enabled) console.info(msg);

                        // scope.feedbackArray[instanceNo] = msg;
                        scope._reportProgress(scope.feedbackArray.join('\<br\>'));
                    }
                };

                var callbackReportError = function (supportDesc, errorMessage) {
                    console.error('LoaderWorkerDirector reported an error: ');
                    console.error(errorMessage);
                    return true;
                };

                var callbackMeshAlter = function (event, override) {
                    if (!THREE.LoaderSupport.Validator.isValid(override)) override = new THREE.LoaderSupport
                        .LoadedMeshUserOverride(false, false);

                    var material = event.detail.material;
                    var meshName = event.detail.meshName;
                    if (THREE.LoaderSupport.Validator.isValid(material) && material.name ===
                        'defaultMaterial' || meshName === 'Mesh_Mesh_head_geo.001_lambert2SG.001') {
                        var materialOverride = material;
                        materialOverride.color = new THREE.Color(Math.random(), Math.random(), Math.random());
                        var mesh = new THREE.Mesh(event.detail.bufferGeometry, material);
                        mesh.name = meshName;
                        override.addMesh(mesh);
                        override.alteredMesh = true;
                    }
                    return override;
                };

                var callbackOnLoadMaterials = function (materials) {
                    console.log('Materials loaded');
                    return materials;
                };

                var callbacks = new THREE.LoaderSupport.Callbacks();
                callbacks.setCallbackOnProgress(callbackReportProgress);
                callbacks.setCallbackOnReportError(callbackReportError);
                callbacks.setCallbackOnLoad(callbackOnLoad);
                callbacks.setCallbackOnMeshAlter(callbackMeshAlter);
                callbacks.setCallbackOnLoadMaterials(callbackOnLoadMaterials);

                this.workerDirector.prepareWorkers(callbacks, maxQueueSize, maxWebWorkers);
                if (this.logging.enabled) console.info('Configuring WWManager with queue size ' + this.workerDirector
                    .getMaxQueueSize() + ' and ' + this.workerDirector.getMaxWebWorkers() + ' workers.');

                var prepData;
                var modelPrepDatas = [];
                for (i = 0; i < maxQueueSize; i++) {
                    prepData = new THREE.LoaderSupport.PrepData(items[i].name);
                    prepData.addResource(new THREE.LoaderSupport.ResourceDescriptor(items[i].path + items[i].name +
                        '.obj', 'OBJ'));
                    prepData.addResource(new THREE.LoaderSupport.ResourceDescriptor(items[i].path + items[i].name +
                        '.mtl', 'MTL'));
                    prepData.setLogging(false, false);
                    prepData.scale = items[i].scale || 1.8;
                    prepData.position = items[i].position || [0, 0, 0];
                    prepData.rotation = items[i].rotation || [0, 0, 0];
                    prepData.name = items[i].name || "";
                    modelPrepDatas.push(prepData);
                }

                var pivot;
                var modelPrepData;
                var scale;
                var position;
                var rotation;
                for (i = 0; i < maxQueueSize; i++) {
                    modelPrepData = modelPrepDatas[i];
                    modelPrepData.useAsync = true;
                    scale = THREE.LoaderSupport.Validator.verifyInput(modelPrepData.scale, 0);
                    position = THREE.LoaderSupport.Validator.verifyInput(modelPrepData.position, [0, 0, 0]);
                    rotation = THREE.LoaderSupport.Validator.verifyInput(modelPrepData.rotation, [0, 0, 0]);
                    modelPrepData = modelPrepData.clone();

                    pivot = new THREE.Object3D();
                    pivot.name = modelPrepData.name;
                    pivot.visible = modelPrepData.visible;
                    if (scale > 0) pivot.scale.set(scale, scale, scale);
                    pivot.position.set(position[0], position[1], position[2]);
                    pivot.rotation.set(rotation[0], rotation[1], rotation[2]);
                    pivot.castShadow = true;
                    pivot.receiveShadow = true;
                    pivot.visible = false;
                    this.scene.add(pivot);
                    modelPrepData.streamMeshesTo = pivot;

                    this.workerDirector.enqueueForRun(modelPrepData);
                }
                this.workerDirector.processQueue();
            },
            recalcAspectRatio: function () {
                this.aspectRatio = (this.canvas.offsetHeight === 0) ? 1 : this.canvas.offsetWidth / this.canvas
                    .offsetHeight;
            },
            resizeDisplayGL: function () {
                this.controls.handleResize();
                this.recalcAspectRatio();
                this.renderer.setSize(this.canvas.offsetWidth, this.canvas.offsetHeight, false);
                this.updateCamera();
            },
            _reportProgress: function (content) {
                var output = content;
                if (THREE.LoaderSupport.Validator.isValid(content) && THREE.LoaderSupport.Validator.isValid(
                        content.detail)) output = content.detail.text;

                output = THREE.LoaderSupport.Validator.verifyInput(output, '');
                if (this.logging.enabled) console.info('Progress:\n\t' + output.replace(/\<br\>/g, '\n\t'));
                document.getElementById('feedback').innerHTML = output;
            },
            resetCamera: function () {
                this.camera.position.copy(this.cameraDefaults.posCamera);
                this.cameraTarget.copy(this.cameraDefaults.posCameraTarget);
                this.updateCamera();
            },
            updateCamera: function () {
                this.camera.aspect = this.aspectRatio;
                this.camera.lookAt(this.cameraTarget);
                this.camera.updateProjectionMatrix();
            },
            initialize: function () {
                var scope = this;

                var CPU = scope.scene.getObjectByName('CPU');
                CPU.position.y = 30 * this.mul;
                CPU.visible = false;
                scope.chassisItems.push(CPU);

                var CPU_Cooler = scope.scene.getObjectByName('CPU-Cooler');
                CPU_Cooler.position.y = 50 * this.mul;
                CPU_Cooler.visible = false;
                scope.chassisItems.push(CPU_Cooler);

                var RAM = scope.scene.getObjectByName('RAM');
                RAM.position.y = 30 * this.mul;
                RAM.visible = false;
                scope.chassisItems.push(RAM);

                var CD_ROM = scope.scene.getObjectByName('CD-ROM');
                CD_ROM.position.y = 40 * this.mul;
                CD_ROM.position.x = 100 * this.mul;
                CD_ROM.visible = false;
                scope.chassisItems.push(CD_ROM);

                var Disk = scope.scene.getObjectByName('Disk');
                Disk.position.y = 30 * this.mul;
                Disk.position.x = -70 * this.mul;
                Disk.visible = false;
                scope.chassisItems.push(Disk);

                var Power = scope.scene.getObjectByName('Power');
                Power.position.y = 250 * this.mul;
                Power.position.z = 160 * this.mul;
                Power.visible = false;
                scope.chassisItems.push(Power);

                var Board = scope.scene.getObjectByName('Board');
                Board.position.z = -80 * this.mul;
                Board.visible = false;
                scope.chassisItems.push(Board);

                var GPU = scope.scene.getObjectByName('GPU');
                GPU.position.y = 60 * this.mul;
                GPU.visible = false;
                scope.chassisItems.push(GPU);

                var Motherboard = scope.scene.getObjectByName('Motherboard');
                Motherboard.visible = true;
                scope.chassisItems.push(Motherboard);

                var Chassis = scope.scene.getObjectByName('Chassis');
                Chassis.position.y = -40 * this.mul;
                Chassis.visible = false;
                scope.chassisItems.push(Chassis);

                var Monitor = scope.scene.getObjectByName('Monitor');
                Monitor.position.y = 100 * this.mul;
                Monitor.visible = false;

                var Mouse = scope.scene.getObjectByName('Mouse');
                Mouse.position.y = 100 * this.mul;
                Mouse.visible = false;

                this.canvas.addEventListener('mousedown', this.onMouseDown.bind(scope), false);
                this.canvas.addEventListener('mousemove', this.onMouseMove.bind(scope), false);

                this.stepSwitch();
                this._reportProgress('');

                document.getElementById('loading').style.display = 'none';
            },
            render: function () {
                if (!this.renderer.autoClear) this.renderer.clear();
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            },
            stepSwitch: function(step) {
                var step = step || this.currentStep || 1;
                var stepObj = this.scene.getObjectByName(this.steps[step]);
                stepObj.visible = true;
                this.stepsOptions[step] = this.stepsOptions[step] || null;
                if (this.stepsOptions[step]) {
                    var _camera = this.stepsOptions[step].cameraPosition || null;
                    var _scene = this.stepsOptions[step].sceneRotation || null;
                    var _obj = this.stepsOptions[step].position || null;
                    if (_scene) {
                        customAnimation.to(this.scene.rotation, 0.5, _scene);
                    }
                    if (_camera) {
                        if (_obj) {
                            _camera.onComplete = function() {
                                customAnimation.to(stepObj.position, 0.6, _obj);
                            };
                        }
                        customAnimation.to(this.camera.position, 0.5, _camera);
                    } else {
                        if (_obj) {
                            customAnimation.to(stepObj.position, 1, _obj);
                        }
                    }
                }
                if (step == 10) {
                    for(var i = 0; i < this.chassisItems.length; i ++) {
                        this.chassisGroup.add(this.chassisItems[i]);
                    }
                    customAnimation.to(this.chassisGroup.position, 0.6, {
                        y: -80
                    });
                }
            },
            trigger: function (obj) {
                console.log('选择：' + obj.name);
                var stepObjPosition = null;
                for(var i = 0; i < this.queueItems.length; i ++) {
                    if (this.queueItems[i].name == obj.name) {
                        stepObjPosition = this.queueItems[i].position;
                        break;
                    }
                }
                customAnimation.to(obj.position, 0.3, {
                    x: stepObjPosition[0],
                    y: stepObjPosition[1],
                    z: stepObjPosition[2]
                });
                this.currentStep += 1;
                if (this.currentStep == this.steps.length) {
                    this.buildComplete();
                } else {
                    this.stepSwitch();
                }
            },
            buildComplete: function() {
                setTimeout(function (scope) {
                    return function() {
                        customAnimation.to(scope.camera.position, 1, {
                            z: 240,
                            x: 0,
                            y: 110,
                            onComplete: function() {
                                setTimeout(function() {
                                    document.getElementById('reset').style.display = 'table';
                                }, 1000)
                            }
                        });
                    }
                }(this), 1000);
            }
        };
        var app = new Boot(document.getElementById('canvas'));
        var resizeWindow = function () {
            app.resizeDisplayGL();
        };
        var render = function () {
            requestAnimationFrame(render);
            app.render();
        };
        window.addEventListener('resize', resizeWindow, false);
        console.log('开始初始化阶段...');
        app.initGL();
        app.resizeDisplayGL();
        render();

        document.getElementById('reset-btn').addEventListener('click', function() {
            app.currentStep = 1;
            app.scene.rotation.z = 0;
            app.camera.position.x = 150;
            app.camera.position.y = 120;
            app.camera.position.z = 200;
            app.chassisItems = [];
            // for(var i in app.chassisGroup.children) {
            //     if (app.chassisGroup.children[i].name != 'ChassisGroup') {
            //         app.chassisGroup.remove(app.chassisGroup.children[i]);
            //     }
            // }
            console.log(app.chassisGroup)
            app.initialize();
        }, false)
    </script>
</body>

</html>