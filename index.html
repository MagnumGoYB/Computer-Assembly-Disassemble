<!DOCTYPE html>
<html lang="en">

<head>
    <title></title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #fff;
            margin: 0px;
            overflow: hidden;
        }

        #full-screen {
            width: 100%;
            height: 100vh;
            min-width: 640px;
            min-height: 360px;
            position: relative;
            overflow: hidden;
            z-index: 0;
        }

        #canvas {
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            background-color: #ffffff;
        }

        #feedback {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display: block;
            color: darkorange;
        }
    </style>
</head>

<body>

    <div id="full-screen">
        <canvas id="canvas"></canvas>
    </div>
    <div id="feedback"></div>

    <script src="js/three.min.js"></script>
    <script src="js/TrackballControls.js"></script>
    <script src="js/DragControls.js"></script>
    <script src="js/LoaderSupport.js"></script>
    <script src="js/OBJLoader2.js"></script>
    <script src="js/MTLLoader.js"></script>
    <script src="js/stats.min.js"></script>

    <script src="js/tween.js"></script>
    <script src="js/animation.js"></script>

    <script>
        var Boot = function (elementToBindTo) {
            this.raycaster = null;
            this.renderer = null;
            this.canvas = elementToBindTo;
            this.aspectRatio = 1;
            this.recalcAspectRatio();
            this.scene = null;
            this.cameraDefaults = {
                posCamera: new THREE.Vector3(150, 120, 200),
                posCameraTarget: new THREE.Vector3(0, 0, 0),
                near: 0.1,
                far: 10000,
                fov: 45
            };
            this.camera = null;
            this.cameraTarget = this.cameraDefaults.posCameraTarget;
            this.controls = null;

            this.workerDirector = new THREE.LoaderSupport.WorkerDirector(THREE.OBJLoader2);
            this.logging = {
                enabled: false,
                debug: false
            };
            this.workerDirector.setLogging(this.logging.enabled, this.logging.debug);
            this.workerDirector.setCrossOrigin('anonymous');
            this.workerDirector.setForceWorkerDataCopy(true);

            this.allAssets = [];
            this.feedbackArray = null;
            this.running = false;

            this.mouse = new THREE.Vector2();
            this.INTERSECTED = null;

            this.queueItems = [{
                    name: 'Motherboard',
                    visible: true,
                    path: 'models/obj/Motherboard/',
                    position: [0, 4, 0],
                    rotation: [0, 0, -1.57]
                },
                {
                    name: 'CPU',
                    path: 'models/obj/CPU/',
                    scale: 1.7,
                    position: [12.4, 1, -6],
                    rotation: [0, 0, -1.57]
                },
                {
                    name: 'CPU-Cooler',
                    path: 'models/obj/CPU-Cooler/',
                    position: [12.4, 8.5, -5],
                    rotation: [0, 0, -1.57]
                },
                {
                    name: 'RAM',
                    path: 'models/obj/RAM/',
                    scale: 1.88,
                    position: [9.6, 4.5, 21],
                    rotation: [0, 0, -1.57]
                },
                {
                    name: 'Chassis',
                    path: 'models/obj/Chassis/',
                    position: [16, 74.5, 43.5],
                    rotation: [0, 0, -1.57]
                },
                {
                    name: 'GPU',
                    path: 'models/obj/GPU/',
                    scale: 1.88,
                    position: [-18, 15, -20],
                    rotation: [0, 0, -1.57]
                },
                {
                    name: 'Disk',
                    path: 'models/obj/Disk/',
                    scale: 1.88,
                    position: [-27.3, 15, 32.5],
                    rotation: [0, 0, -1.57]
                },
                {
                    name: 'CD-ROM',
                    path: 'models/obj/CD-ROM/',
                    scale: 1.81,
                    position: [30.3, 17, 27.7],
                    rotation: [0, 0.01, -1.57]
                },
                {
                    name: 'Power',
                    path: 'models/obj/Power/',
                    scale: 1.8,
                    position: [23.5, 227, 14],
                    rotation: [0, 0, -1.57]
                },
                {
                    name: 'Board',
                    path: 'models/obj/Board/',
                    scale: 1.805,
                    position: [16.2, -125, 44],
                    rotation: [0, 0, -1.57]
                }
            ];
            this.workerCount = 3;
            this.streamMeshes = true;

            this.mul = 2;
            this.currentStep = 1;
            this.steps = ['', 'CPU', 'CPU-Cooler', 'RAM', 'Chassis', 'GPU', 'Disk'];
            this.stepsOptions = [null, {
                position: {
                    y: 30
                },
                cameraPosition: {
                    x: 80,
                    y: 100,
                    z: 10
                }
            }, {
                position: {
                    y: 40
                }
            }, {
                position: {
                    y: 15
                },
                cameraPosition: {
                    x: 0,
                    y: 40,
                    z: 80
                }
            }, {
                position: {
                    y: 10
                },
                cameraPosition: {
                    x: 160,
                    y: 80,
                    z: 80
                }
            }, {
                position: {
                    y: 50
                },
                cameraPosition: {
                    x: -120,
                    y: 150,
                    z: 40
                }
            }, {
                position: {
                    y: 60,
                    x: -20,
                    z: 20
                },
                cameraPosition: {
                    x: 50,
                    y: 200,
                    z: -100
                }
            }];
        };
        Boot.prototype = {
            constructor: Boot,
            initGL: function () {
                this.raycaster = new THREE.Raycaster();
                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.canvas,
                    antialias: true,
                    autoClear: true
                });
                this.renderer.setClearColor(0xFFFFFF);
                this.renderer.shadowMap.enabled = true
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap

                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xD6D9DC);

                this.camera = new THREE.PerspectiveCamera(this.cameraDefaults.fov, this.aspectRatio, this.cameraDefaults
                    .near, this.cameraDefaults.far);
                this.resetCamera();
                this.controls = new THREE.TrackballControls(this.camera, this.renderer.domElement);

                var ambientLight = new THREE.AmbientLight(0xFFFFFF, 1);
                var directionalLight = new THREE.DirectionalLight(0xFFFFFF, 0.3);
                directionalLight.position.set(-100, 100, -100);
                directionalLight.castShadow = true;
                var directional2Light = new THREE.DirectionalLight(0xFFFFFF, 0.3);
                directional2Light.position.set(-100, 0, 100);
                directional2Light.castShadow = true;
                var directional3Light = new THREE.DirectionalLight(0xFFFFFF, 0.3);
                directional3Light.position.set(100, -100, 0);
                directional3Light.castShadow = true;

                this.scene.add(ambientLight);
                this.scene.add(directionalLight);
                this.scene.add(directional2Light);
                this.scene.add(directional3Light);

                var grid = new THREE.GridHelper(1000, 100, 0x404040, 0x404040);
                grid.material.opacity = 0.05;
                grid.material.transparent = true;
                // this.scene.add(grid);

                var axes = new THREE.AxisHelper(1000);
                this.scene.add(axes);

                this.pivot = new THREE.Object3D();
                this.pivot.name = 'Pivot';
                this.scene.add(this.pivot);

                this.enqueueAllAssests(this.queueItems, this.workerCount, this.streamMeshes);
            },
            onMouseDown: function (e) {
                e.preventDefault();
                this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);
                var scensObjs = [];
                this.scene.children.forEach(child => {
                    for (var i = 0; i < child.children.length; i++) {
                        var obj = child.children[i];
                        scensObjs.push(obj);
                    }
                });
                var intersects = this.raycaster.intersectObjects(scensObjs);

                var objs = [];
                for (var i = 0; i < intersects.length; i++) {
                    var intersect = intersects[i];
                    if (intersect.object instanceof THREE.Mesh) {
                        var obj = intersect.object.parent;
                        obj.userData.distance = intersect.distance;
                        objs.push(obj);
                    }
                }
                objs = objs.sort(function (a, b) {
                    return a.userData.distance - b.userData.distance;
                });
                if (objs[0]) {
                    if (objs[0].name == this.steps[this.currentStep]) {
                        this.trigger(objs[0]);
                    }
                }
            },
            onMouseMove: function(e) {},
            enqueueAllAssests: function (items, maxWebWorkers, streamMeshes) {
                if (this.running) {
                    return;
                } else {
                    this.running = true;
                }
                var scope = this;
                scope.workerDirector.objectsCompleted = 0;
                scope.feedbackArray = [];
                scope.reportDonwload = [];
                var i;
                var maxQueueSize = items.length;
                for (i = 0; i < maxWebWorkers; i++) {
                    scope.feedbackArray[i] = 'Worker #' + i + ': Awaiting feedback';
                    scope.reportDonwload[i] = true;
                }
                scope._reportProgress(scope.feedbackArray.join('\<br\>'));

                var callbackOnLoad = function (event) {
                    var instanceNo = event.detail.instanceNo;
                    scope.reportDonwload[instanceNo] = false;
                    scope.allAssets.push(event.detail.loaderRootNode);

                    var msg = 'Worker #' + instanceNo + ': Completed loading: ' + event.detail.modelName +
                        ' (#' + scope.workerDirector.objectsCompleted + ')';
                    if (scope.logging.enabled) console.info(msg);
                    scope.feedbackArray[instanceNo] = msg;
                    scope._reportProgress(scope.feedbackArray.join('\<br\>'));

                    if (scope.workerDirector.objectsCompleted + 1 === maxQueueSize) {
                        scope.running = false;
                        console.log('所有对象加载完成！');
                        scope.initialize();
                    }
                };

                var callbackReportProgress = function (event) {
                    var instanceNo = event.detail.instanceNo;
                    var text = event.detail.text;

                    if (scope.reportDonwload[instanceNo]) {
                        var msg = 'Worker #' + instanceNo + ': ' + text;
                        if (scope.logging.enabled) console.info(msg);

                        scope.feedbackArray[instanceNo] = msg;
                        scope._reportProgress(scope.feedbackArray.join('\<br\>'));
                    }
                };

                var callbackReportError = function (supportDesc, errorMessage) {
                    console.error('LoaderWorkerDirector reported an error: ');
                    console.error(errorMessage);
                    return true;
                };

                var callbackMeshAlter = function (event, override) {
                    if (!THREE.LoaderSupport.Validator.isValid(override)) override = new THREE.LoaderSupport
                        .LoadedMeshUserOverride(false, false);

                    var material = event.detail.material;
                    var meshName = event.detail.meshName;
                    if (THREE.LoaderSupport.Validator.isValid(material) && material.name ===
                        'defaultMaterial' || meshName === 'Mesh_Mesh_head_geo.001_lambert2SG.001') {
                        var materialOverride = material;
                        materialOverride.color = new THREE.Color(Math.random(), Math.random(), Math.random());
                        var mesh = new THREE.Mesh(event.detail.bufferGeometry, material);
                        mesh.name = meshName;
                        override.addMesh(mesh);
                        override.alteredMesh = true;
                    }
                    return override;
                };

                var callbackOnLoadMaterials = function (materials) {
                    console.log('Materials loaded');
                    return materials;
                };

                var callbacks = new THREE.LoaderSupport.Callbacks();
                callbacks.setCallbackOnProgress(callbackReportProgress);
                callbacks.setCallbackOnReportError(callbackReportError);
                callbacks.setCallbackOnLoad(callbackOnLoad);
                callbacks.setCallbackOnMeshAlter(callbackMeshAlter);
                callbacks.setCallbackOnLoadMaterials(callbackOnLoadMaterials);

                this.workerDirector.prepareWorkers(callbacks, maxQueueSize, maxWebWorkers);
                if (this.logging.enabled) console.info('Configuring WWManager with queue size ' + this.workerDirector
                    .getMaxQueueSize() + ' and ' + this.workerDirector.getMaxWebWorkers() + ' workers.');

                var prepData;
                var modelPrepDatas = [];
                for (i = 0; i < maxQueueSize; i++) {
                    prepData = new THREE.LoaderSupport.PrepData(items[i].name);
                    prepData.addResource(new THREE.LoaderSupport.ResourceDescriptor(items[i].path + items[i].name +
                        '.obj', 'OBJ'));
                    prepData.addResource(new THREE.LoaderSupport.ResourceDescriptor(items[i].path + items[i].name +
                        '.mtl', 'MTL'));
                    prepData.setLogging(false, false);
                    prepData.scale = items[i].scale || 1.8;
                    prepData.position = items[i].position || [0, 0, 0];
                    prepData.rotation = items[i].rotation || [0, 0, 0];
                    prepData.name = items[i].name || "";
                    modelPrepDatas.push(prepData);
                }

                var pivot;
                var modelPrepData;
                var scale;
                var position;
                var rotation;
                for (i = 0; i < maxQueueSize; i++) {
                    modelPrepData = modelPrepDatas[i];
                    modelPrepData.useAsync = true;
                    scale = THREE.LoaderSupport.Validator.verifyInput(modelPrepData.scale, 0);
                    position = THREE.LoaderSupport.Validator.verifyInput(modelPrepData.position, [0, 0, 0]);
                    rotation = THREE.LoaderSupport.Validator.verifyInput(modelPrepData.rotation, [0, 0, 0]);
                    modelPrepData = modelPrepData.clone();

                    pivot = new THREE.Object3D();
                    pivot.name = modelPrepData.name;
                    pivot.visible = modelPrepData.visible;
                    if (scale > 0) pivot.scale.set(scale, scale, scale);
                    pivot.position.set(position[0], position[1], position[2]);
                    pivot.rotation.set(rotation[0], rotation[1], rotation[2]);
                    pivot.castShadow = true;
                    pivot.receiveShadow = true;
                    pivot.visible = false;
                    this.scene.add(pivot);
                    modelPrepData.streamMeshesTo = pivot;

                    this.workerDirector.enqueueForRun(modelPrepData);
                }
                this.workerDirector.processQueue();
            },
            recalcAspectRatio: function () {
                this.aspectRatio = (this.canvas.offsetHeight === 0) ? 1 : this.canvas.offsetWidth / this.canvas
                    .offsetHeight;
            },
            resizeDisplayGL: function () {
                this.controls.handleResize();
                this.recalcAspectRatio();
                this.renderer.setSize(this.canvas.offsetWidth, this.canvas.offsetHeight, false);
                this.updateCamera();
            },
            _reportProgress: function (content) {
                var output = content;
                if (THREE.LoaderSupport.Validator.isValid(content) && THREE.LoaderSupport.Validator.isValid(
                        content.detail)) output = content.detail.text;

                output = THREE.LoaderSupport.Validator.verifyInput(output, '');
                if (this.logging.enabled) console.info('Progress:\n\t' + output.replace(/\<br\>/g, '\n\t'));
                document.getElementById('feedback').innerHTML = output;
            },
            resetCamera: function () {
                this.camera.position.copy(this.cameraDefaults.posCamera);
                this.cameraTarget.copy(this.cameraDefaults.posCameraTarget);
                this.updateCamera();
            },
            updateCamera: function () {
                this.camera.aspect = this.aspectRatio;
                this.camera.lookAt(this.cameraTarget);
                this.camera.updateProjectionMatrix();
            },
            initialize: function () {
                var scope = this;

                var CPU = scope.scene.getObjectByName('CPU');
                // CPU.visible = true;
                CPU.position.y = 30 * this.mul;

                var CPU_Cooler = scope.scene.getObjectByName('CPU-Cooler');
                // CPU_Cooler.visible = true;
                CPU_Cooler.position.y = 50 * this.mul;

                var RAM = scope.scene.getObjectByName('RAM');
                // RAM.visible = true;
                RAM.position.y = 30 * this.mul;

                var CD_ROM = scope.scene.getObjectByName('CD-ROM');
                // CD_ROM.visible = true;
                CD_ROM.position.y = 40 * this.mul;
                CD_ROM.position.x = 100 * this.mul;

                var Disk = scope.scene.getObjectByName('Disk');
                // Disk.visible = true;
                Disk.position.y = 30 * this.mul;
                Disk.position.x = -70 * this.mul;

                var Power = scope.scene.getObjectByName('Power');
                // Power.visible = true;
                Power.position.y = 250 * this.mul;
                Power.position.z = 160 * this.mul;

                var Board = scope.scene.getObjectByName('Board');
                // Board.visible = true;
                Board.position.z = -80 * this.mul;

                var GPU = scope.scene.getObjectByName('GPU');
                // GPU.visible = true;
                GPU.position.y = 60 * this.mul;

                var Motherboard = scope.scene.getObjectByName('Motherboard');
                Motherboard.visible = true;

                var Chassis = scope.scene.getObjectByName('Chassis');
                // Chassis.visible = true;
                Chassis.position.y = -20 * this.mul;

                this.canvas.addEventListener('mousedown', this.onMouseDown.bind(scope), false);
                this.canvas.addEventListener('mousemove', this.onMouseMove.bind(scope), false);

                this.stepSwitch();
            },
            render: function () {
                if (!this.renderer.autoClear) this.renderer.clear();
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            },
            stepSwitch: function(step) {
                var step = step || this.currentStep || 1;
                var stepObj = this.scene.getObjectByName(this.steps[step]);
                stepObj.visible = true;
                this.stepsOptions[step] = this.stepsOptions[step] || null;
                if (this.stepsOptions[step]) {
                    var _camera = this.stepsOptions[step].cameraPosition || null;
                    var _obj = this.stepsOptions[step].position || null;
                    if (_camera) {
                        if (_obj) {
                            _camera.onComplete = function() {
                                customAnimation.to(stepObj.position, 1, _obj);
                            };
                        }
                        customAnimation.to(this.camera.position, 0.5, _camera);
                    } else {
                        if (_obj) {
                            customAnimation.to(stepObj.position, 1, _obj);
                        }
                    }
                }
            },
            trigger: function (obj) {
                console.log('选择：' + obj.name);
                var stepObjPosition = null;
                for(var i = 0; i < this.queueItems.length; i ++) {
                    if (this.queueItems[i].name == obj.name) {
                        stepObjPosition = this.queueItems[i].position;
                        break;
                    }
                }
                customAnimation.to(obj.position, 0.3, {
                    x: stepObjPosition[0],
                    y: stepObjPosition[1],
                    z: stepObjPosition[2]
                });
                this.currentStep += 1;
                this.stepSwitch();
            }
        };
        var app = new Boot(document.getElementById('canvas'));
        var resizeWindow = function () {
            app.resizeDisplayGL();
        };
        var render = function () {
            requestAnimationFrame(render);
            app.render();
        };
        window.addEventListener('resize', resizeWindow, false);
        console.log('开始初始化阶段...');
        app.initGL();
        app.resizeDisplayGL();
        render();
    </script>
</body>

</html>